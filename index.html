<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Nonaga - Hexagonal Strategy Game</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      touch-action: manipulation;
    }
    #root {
      width: 100%;
      min-height: 100%;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect } = React;

    // Hexagonal grid constants
    const DIRECTIONS = [
      { q: 1, r: -1 }, { q: 1, r: 0 }, { q: 0, r: 1 },
      { q: -1, r: 1 }, { q: -1, r: 0 }, { q: 0, r: -1 },
    ];

    const INITIAL_DISCS = [
      { q: 0, r: 0 },
      { q: 1, r: -1 }, { q: 1, r: 0 }, { q: 0, r: 1 },
      { q: -1, r: 1 }, { q: -1, r: 0 }, { q: 0, r: -1 },
      { q: 2, r: -2 }, { q: 2, r: -1 }, { q: 2, r: 0 },
      { q: 1, r: 1 }, { q: 0, r: 2 }, { q: -1, r: 2 },
      { q: -2, r: 2 }, { q: -2, r: 1 }, { q: -2, r: 0 },
      { q: -1, r: -1 }, { q: 0, r: -2 }, { q: 1, r: -2 },
    ];

    const INITIAL_PIECES = {
      red: [{ q: 2, r: -2 }, { q: -1, r: 2 }, { q: -1, r: -1 }],
      black: [{ q: 2, r: 0 }, { q: -2, r: 2 }, { q: 0, r: -2 }],
    };

    const coordKey = (q, r) => `${q},${r}`;
    const parseKey = (key) => {
      const [q, r] = key.split(',').map(Number);
      return { q, r };
    };

    const hexToPixel = (q, r, size) => {
      const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
      const y = size * (3 / 2 * r);
      return { x, y };
    };

    const areNeighbors = (pos1, pos2) => {
      const dq = pos1.q - pos2.q;
      const dr = pos1.r - pos2.r;
      return DIRECTIONS.some(d => d.q === dq && d.r === dr);
    };

    function Nonaga() {
      const [discs, setDiscs] = useState(INITIAL_DISCS);
      const [pieces, setPieces] = useState(INITIAL_PIECES);
      const [currentPlayer, setCurrentPlayer] = useState('red');
      const [phase, setPhase] = useState('movePiece');
      const [selectedPiece, setSelectedPiece] = useState(null);
      const [selectedDisc, setSelectedDisc] = useState(null);
      const [lastMovedDisc, setLastMovedDisc] = useState(null);
      const [validMoves, setValidMoves] = useState([]);
      const [winner, setWinner] = useState(null);
      
      // Responsive sizing
      const [dimensions, setDimensions] = useState({ width: 600, height: 700 });
      
      useEffect(() => {
        const updateSize = () => {
          const w = Math.min(window.innerWidth, 600);
          const h = Math.min(window.innerHeight, 800);
          setDimensions({ width: w, height: h });
        };
        updateSize();
        window.addEventListener('resize', updateSize);
        return () => window.removeEventListener('resize', updateSize);
      }, []);
      
      const HEX_SIZE = Math.min(dimensions.width / 14, 42);
      const CENTER_X = dimensions.width / 2;
      const CENTER_Y = dimensions.height * 0.4;

      const discSet = useMemo(() => {
        return new Set(discs.map(d => coordKey(d.q, d.r)));
      }, [discs]);

      const pieceMap = useMemo(() => {
        const map = {};
        pieces.red.forEach(p => { map[coordKey(p.q, p.r)] = 'red'; });
        pieces.black.forEach(p => { map[coordKey(p.q, p.r)] = 'black'; });
        return map;
      }, [pieces]);

      const checkWin = useCallback((playerPieces) => {
        if (playerPieces.length !== 3) return false;
        const [p1, p2, p3] = playerPieces;
        const n12 = areNeighbors(p1, p2);
        const n23 = areNeighbors(p2, p3);
        const n13 = areNeighbors(p1, p3);
        const adjacentCount = (n12 ? 1 : 0) + (n23 ? 1 : 0) + (n13 ? 1 : 0);
        return adjacentCount >= 2;
      }, []);

      const getValidPieceMoves = useCallback((piece) => {
        const moves = [];
        for (const dir of DIRECTIONS) {
          let q = piece.q + dir.q;
          let r = piece.r + dir.r;
          let lastValid = null;
          while (discSet.has(coordKey(q, r))) {
            if (pieceMap[coordKey(q, r)]) {
              break;
            }
            lastValid = { q, r };
            q += dir.q;
            r += dir.r;
          }
          if (lastValid) {
            moves.push(lastValid);
          }
        }
        return moves;
      }, [discSet, pieceMap]);

      const isEdgeDisc = useCallback((disc) => {
        let neighborCount = 0;
        for (const dir of DIRECTIONS) {
          const key = coordKey(disc.q + dir.q, disc.r + dir.r);
          if (discSet.has(key)) neighborCount++;
        }
        return neighborCount < 6;
      }, [discSet]);

      const wouldDisconnectBoard = useCallback((discToRemove, newDiscs) => {
        if (newDiscs.length <= 1) return false;
        const remaining = newDiscs.filter(d => d.q !== discToRemove.q || d.r !== discToRemove.r);
        if (remaining.length === 0) return true;
        const visited = new Set();
        const queue = [remaining[0]];
        visited.add(coordKey(remaining[0].q, remaining[0].r));
        while (queue.length > 0) {
          const current = queue.shift();
          for (const dir of DIRECTIONS) {
            const neighborKey = coordKey(current.q + dir.q, current.r + dir.r);
            if (!visited.has(neighborKey)) {
              const neighbor = remaining.find(d => coordKey(d.q, d.r) === neighborKey);
              if (neighbor) {
                visited.add(neighborKey);
                queue.push(neighbor);
              }
            }
          }
        }
        return visited.size !== remaining.length;
      }, []);

      const getValidDiscPlacements = useCallback((disc) => {
        const placements = [];
        const remainingDiscs = discs.filter(d => d.q !== disc.q || d.r !== disc.r);
        const remainingSet = new Set(remainingDiscs.map(d => coordKey(d.q, d.r)));
        const candidates = new Set();
        for (const d of remainingDiscs) {
          for (const dir of DIRECTIONS) {
            const key = coordKey(d.q + dir.q, d.r + dir.r);
            if (!remainingSet.has(key)) {
              candidates.add(key);
            }
          }
        }
        for (const key of candidates) {
          const { q, r } = parseKey(key);
          let adjacentCount = 0;
          for (const dir of DIRECTIONS) {
            if (remainingSet.has(coordKey(q + dir.q, r + dir.r))) {
              adjacentCount++;
            }
          }
          if (adjacentCount >= 2) {
            const testDiscs = [...remainingDiscs, { q, r }];
            if (!wouldDisconnectBoard(disc, testDiscs)) {
              placements.push({ q, r });
            }
          }
        }
        return placements;
      }, [discs, wouldDisconnectBoard]);

      const handleDiscClick = useCallback((disc) => {
        if (winner) return;
        const key = coordKey(disc.q, disc.r);
        const pieceOnDisc = pieceMap[key];

        if (phase === 'movePiece') {
          if (pieceOnDisc === currentPlayer) {
            setSelectedPiece(disc);
            setValidMoves(getValidPieceMoves(disc));
          } else if (selectedPiece && !pieceOnDisc) {
            const isValidMove = validMoves.some(m => m.q === disc.q && m.r === disc.r);
            if (isValidMove) {
              const newPieces = { ...pieces };
              newPieces[currentPlayer] = newPieces[currentPlayer].map(p => 
                p.q === selectedPiece.q && p.r === selectedPiece.r 
                  ? { q: disc.q, r: disc.r } 
                  : p
              );
              setPieces(newPieces);
              setSelectedPiece(null);
              setValidMoves([]);
              if (checkWin(newPieces[currentPlayer])) {
                setWinner(currentPlayer);
                return;
              }
              setPhase('moveDisc');
            }
          }
        } else if (phase === 'moveDisc') {
          const isExistingDisc = discSet.has(key);
          if (selectedDisc) {
            const isValidPlacement = validMoves.some(m => m.q === disc.q && m.r === disc.r);
            if (isValidPlacement) {
              const newDiscs = discs.filter(d => d.q !== selectedDisc.q || d.r !== selectedDisc.r);
              newDiscs.push({ q: disc.q, r: disc.r });
              setDiscs(newDiscs);
              setLastMovedDisc({ q: disc.q, r: disc.r });
              setSelectedDisc(null);
              setValidMoves([]);
              setPhase('movePiece');
              setCurrentPlayer(currentPlayer === 'red' ? 'black' : 'red');
              return;
            }
          }
          const isLastMoved = lastMovedDisc && disc.q === lastMovedDisc.q && disc.r === lastMovedDisc.r;
          if (isExistingDisc && !pieceOnDisc && isEdgeDisc(disc) && !isLastMoved) {
            setSelectedDisc(disc);
            setValidMoves(getValidDiscPlacements(disc));
          }
        }
      }, [winner, phase, currentPlayer, selectedPiece, selectedDisc, pieces, discs, validMoves, 
          pieceMap, discSet, lastMovedDisc, getValidPieceMoves, getValidDiscPlacements, isEdgeDisc, checkWin]);

      const resetGame = () => {
        setDiscs(INITIAL_DISCS);
        setPieces(INITIAL_PIECES);
        setCurrentPlayer('red');
        setPhase('movePiece');
        setSelectedPiece(null);
        setSelectedDisc(null);
        setLastMovedDisc(null);
        setValidMoves([]);
        setWinner(null);
      };

      const renderDisc = (disc, index) => {
        const { x, y } = hexToPixel(disc.q, disc.r, HEX_SIZE);
        const screenX = CENTER_X + x;
        const screenY = CENTER_Y + y;
        const key = coordKey(disc.q, disc.r);
        const piece = pieceMap[key];
        const isSelected = selectedPiece && selectedPiece.q === disc.q && selectedPiece.r === disc.r;
        const isSelectedDisc = selectedDisc && selectedDisc.q === disc.q && selectedDisc.r === disc.r;
        const isLastMoved = lastMovedDisc && disc.q === lastMovedDisc.q && disc.r === lastMovedDisc.r;
        
        let isClickable = false;
        let strokeColor = 'rgba(0,0,0,0.2)';
        let strokeWidth = 1;

        if (!winner) {
          if (phase === 'movePiece') {
            if (piece === currentPlayer || (selectedPiece && !piece)) {
              isClickable = true;
            }
          } else if (phase === 'moveDisc') {
            if (!piece && isEdgeDisc(disc) && !isLastMoved) {
              isClickable = true;
              strokeColor = '#5dade2';
              strokeWidth = 2;
            }
          }
        }

        if (isSelected || isSelectedDisc) {
          strokeColor = '#f1c40f';
          strokeWidth = 3;
        }

        const discRadius = HEX_SIZE * 0.9;

        return (
          <g 
            key={`disc-${index}`} 
            onClick={() => handleDiscClick(disc)}
            onTouchEnd={(e) => { e.preventDefault(); handleDiscClick(disc); }}
            style={{ cursor: isClickable ? 'pointer' : 'default' }}
          >
            <ellipse
              cx={screenX}
              cy={screenY + discRadius * 0.1}
              rx={discRadius * 0.95}
              ry={discRadius * 0.85}
              fill="rgba(0, 0, 0, 0.3)"
            />
            <circle
              cx={screenX}
              cy={screenY}
              r={discRadius}
              fill="linear-gradient(145deg, #d4c4a8, #c4b498)"
              stroke={strokeColor}
              strokeWidth={strokeWidth}
              style={{ transition: 'all 0.2s ease' }}
            />
            <circle
              cx={screenX}
              cy={screenY}
              r={discRadius * 0.9}
              fill="none"
              stroke="rgba(139, 119, 101, 0.2)"
              strokeWidth={1}
            />
            {piece && (
              <g>
                <ellipse
                  cx={screenX}
                  cy={screenY + HEX_SIZE * 0.08}
                  rx={HEX_SIZE * 0.52}
                  ry={HEX_SIZE * 0.38}
                  fill="rgba(0, 0, 0, 0.4)"
                />
                <circle
                  cx={screenX}
                  cy={screenY}
                  r={HEX_SIZE * 0.48}
                  fill={`url(#${piece}Piece)`}
                  stroke="rgba(0,0,0,0.3)"
                  strokeWidth={2}
                  filter={isSelected ? 'url(#glow)' : ''}
                  style={{ transition: 'all 0.2s ease' }}
                />
                <ellipse
                  cx={screenX - HEX_SIZE * 0.12}
                  cy={screenY - HEX_SIZE * 0.14}
                  rx={HEX_SIZE * 0.19}
                  ry={HEX_SIZE * 0.12}
                  fill="rgba(255, 255, 255, 0.3)"
                />
              </g>
            )}
          </g>
        );
      };

      const renderValidMove = (move, index) => {
        const { x, y } = hexToPixel(move.q, move.r, HEX_SIZE);
        const screenX = CENTER_X + x;
        const screenY = CENTER_Y + y;
        return (
          <circle
            key={`valid-${index}`}
            cx={screenX}
            cy={screenY}
            r={HEX_SIZE * 0.9}
            fill="rgba(46, 204, 113, 0.2)"
            stroke="#2ecc71"
            strokeWidth={2}
            strokeDasharray="8 4"
            onClick={() => handleDiscClick(move)}
            onTouchEnd={(e) => { e.preventDefault(); handleDiscClick(move); }}
            style={{ animation: 'pulse 1.5s ease-in-out infinite', cursor: 'pointer' }}
          />
        );
      };

      const fontSize = Math.max(12, HEX_SIZE * 0.35);

      return (
        <div style={{
          minHeight: '100vh',
          background: 'linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
          fontFamily: '"Playfair Display", Georgia, serif',
          color: '#e8e8e8',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          padding: '10px',
          paddingBottom: '20px',
        }}>
          <style>
            {`@keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }`}
          </style>
          
          <div style={{ textAlign: 'center', marginBottom: '10px' }}>
            <h1 style={{
              fontSize: `${Math.max(1.8, HEX_SIZE * 0.08)}rem`,
              fontWeight: 700,
              letterSpacing: '0.2em',
              margin: 0,
              background: 'linear-gradient(135deg, #e8d5b7 0%, #f5e6d3 50%, #d4a574 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}>
              NONAGA
            </h1>
          </div>

          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '12px',
            marginBottom: '10px',
            padding: '10px 16px',
            background: 'rgba(255, 255, 255, 0.05)',
            borderRadius: '10px',
            border: '1px solid rgba(255, 255, 255, 0.1)',
            flexWrap: 'wrap',
            justifyContent: 'center',
          }}>
            {winner ? (
              <div style={{
                fontSize: `${fontSize * 1.2}px`,
                fontWeight: 600,
                color: winner === 'red' ? '#e74c3c' : '#5dade2',
              }}>
                üèÜ {winner === 'red' ? 'Red' : 'Black'} wins!
              </div>
            ) : (
              <>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <div style={{
                    width: '20px',
                    height: '20px',
                    borderRadius: '50%',
                    background: currentPlayer === 'red' 
                      ? 'radial-gradient(circle at 30% 30%, #ff6b6b, #c0392b)'
                      : 'radial-gradient(circle at 30% 30%, #5a6c7d, #2c3e50)',
                    boxShadow: currentPlayer === 'red'
                      ? '0 4px 15px rgba(231, 76, 60, 0.5)'
                      : '0 4px 15px rgba(44, 62, 80, 0.5)',
                  }} />
                  <span style={{ fontSize: `${fontSize}px`, fontWeight: 500 }}>
                    {currentPlayer === 'red' ? 'Red' : 'Black'}'s Turn
                  </span>
                </div>
                <div style={{
                  fontFamily: '"Courier New", monospace',
                  fontSize: `${fontSize * 0.85}px`,
                  color: '#8892b0',
                }}>
                  {phase === 'movePiece' ? '‚ë† Move piece' : '‚ë° Move disc'}
                </div>
              </>
            )}
          </div>

          <div style={{ position: 'relative', marginBottom: '15px' }}>
            <svg 
              width={dimensions.width} 
              height={dimensions.height * 0.65}
              style={{ filter: 'drop-shadow(0 10px 20px rgba(0, 0, 0, 0.4))' }}
            >
              <defs>
                <radialGradient id="boardGlow" cx="50%" cy="50%" r="50%">
                  <stop offset="0%" stopColor="rgba(100, 150, 200, 0.1)" />
                  <stop offset="100%" stopColor="transparent" />
                </radialGradient>
                <radialGradient id="redPiece" cx="30%" cy="30%" r="70%">
                  <stop offset="0%" stopColor="#ff6b6b" />
                  <stop offset="50%" stopColor="#e74c3c" />
                  <stop offset="100%" stopColor="#c0392b" />
                </radialGradient>
                <radialGradient id="blackPiece" cx="30%" cy="30%" r="70%">
                  <stop offset="0%" stopColor="#5a6c7d" />
                  <stop offset="50%" stopColor="#34495e" />
                  <stop offset="100%" stopColor="#2c3e50" />
                </radialGradient>
                <filter id="glow">
                  <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                  <feMerge>
                    <feMergeNode in="coloredBlur" />
                    <feMergeNode in="SourceGraphic" />
                  </feMerge>
                </filter>
              </defs>
              <circle cx={CENTER_X} cy={CENTER_Y} r={HEX_SIZE * 6} fill="url(#boardGlow)" />
              {validMoves.map(renderValidMove)}
              {discs.map(renderDisc)}
            </svg>
          </div>

          <button
            onClick={resetGame}
            style={{
              padding: '12px 28px',
              fontSize: `${fontSize}px`,
              fontWeight: 600,
              color: '#e8e8e8',
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              boxShadow: '0 4px 15px rgba(102, 126, 234, 0.4)',
              transition: 'all 0.3s ease',
            }}
          >
            New Game
          </button>

          <div style={{
            marginTop: '15px',
            padding: '12px',
            background: 'rgba(255, 255, 255, 0.03)',
            borderRadius: '8px',
            maxWidth: '350px',
            width: '90%',
          }}>
            <h3 style={{ 
              margin: '0 0 8px 0', 
              fontSize: `${fontSize}px`,
              color: '#a8b2d1' 
            }}>How to Win</h3>
            <p style={{ 
              margin: 0, 
              fontSize: `${fontSize * 0.85}px`, 
              color: '#8892b0',
              lineHeight: 1.5,
            }}>
              Line up your 3 pieces in a <strong>line</strong>, <strong>triangle</strong>, or <strong>V-shape</strong>
            </p>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Nonaga />);
  </script>
</body>
</html>
